
\chapter{Use Cases}

During my start-up-company days\footnote{None of my entrepreneurial endeavors
ended in IPOs or lucrative buy-outs, partially because of the lessons of this
chapter.}, it occurred to me that in order to have a successful product, you
need to do two important things:

\begin{compactenum}
\item Build the right thing.
\item Build the thing right.
\end{compactenum}

By the first of these requirements, I mean you have to create a product that
actually helps people, that truly meets a need, lessens a pain, scratches an
itch, or makes their life better in some way. The second one means you have to
engineer it well: to make it efficient and proficient, with an elegant design
that is easily maintainable, reasonably bug-free, and compatible with future
technology changes in a fairly painless way.

Thought experiment: if your project team could only manage to do well at
\textit{one} of these activities, which would you choose? (Take a moment and
consider before reading further.)

Here's my answer. It is certainly important to design and code things well so
that your software product will be robust, flexible, and extensible for the
long haul. But if you can only excel at one of the two above requirements, my
advice is to make darn sure it's the first one. If you screw up the second
one, you're going to have a bunch of pissed-off customers, and of course
nobody wants that. Twitter and Facebook will light up with complaints about
how your product is buggy, doesn't do what was advertised, has trouble
integrating with other software, keeps missing release dates, and so forth.
Yes, indeed that's a headache.

But if you screw up the first one, you're going to have \textit{no} customers.
And believe me, that's a lot worse. Your well-built, snazzy-looking, bug-free
little product isn't going to get any airtime on social media because
\textit{nobody cares}. It simply isn't something they find worth using, and so
all the great engineering in the world isn't going to be of any use.

Incidentally, if there's lots of complaining on the Internet about how your
product is buggy, that's actually a really nice situation to have. It means
that people are using your code, and that they care enough to gripe. You've
(partially) solved a problem that they genuinely want solved, and that means
that ultimately, if you can manage to get \#2 under control, you're going to
have a market and a chance at a big success.

Here's another thought experiment: why, if \#1 is the most important thing to
get right, do we spend almost the entire Computer Science curriculum teaching
students how to do \#2 well? Think about it: just about every course you've
taken (and will ever take) involves some aspect of \#2.

I think the answer to this is multifold, but much of it comes down to the fact
that \#1 is just harder to teach. It's certainly not as predictable as \#2.
Not as much is known about it. For the various aspects of \#2, there are quite
a few reliable and even quantifiable techniques that the Computer Science
community has discovered and which have stood the test of time. If you follow
best practices, you're going to end up building your code right. But knowing
what program to write in the first place is a different realm entirely, and it
requires a lot of intuition about people and their fickleness. 

Steve Jobs was a genius at \#1, and he had Steve Wozniak as his wingman doing
\#2. When top engineers came and went at Apple, the company could survive the
changes because the principles they were using were transcendent. When Jobs
wasn't there, though, you could sure see the difference.

\section{Capturing requirements}

This chapter is a brief foray into a different phase of the \textbf{software
lifecycle} than you're used to studying.



