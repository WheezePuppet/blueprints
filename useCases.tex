
\chapter{Use Cases}

During my start-up-company days\footnote{None of my entrepreneurial endeavors
ended in IPOs or lucrative buy-outs, partially because of the lessons of this
chapter.}, it occurred to me that in order to have a successful product, you
need to do two important things:

\begin{compactenum}
\item Build the right thing.
\item Build the thing right.
\end{compactenum}

By the first of these items, I mean you have to create a product that actually
helps people, that truly meets a need, lessens some pain, scratches an itch,
or makes their life better in some way. The second one means you have to
engineer it well: to make it efficient and proficient, with an elegant design
that is easily maintainable, reasonably bug-free, and adaptable to future
technology changes.

Thought experiment: if your project team could only manage to do well at
\textit{one} of these activities, which would you choose? (Take a moment and
consider before reading further.)

Here's my answer. It is certainly important to design and code things well so
that your software product will be robust, flexible, and extensible for the
long haul. But if you can only excel at one of the two above items, my advice
is to make darn sure it's the first one.

Here's why. If you screw up the second one, you're going to have a bunch of
pissed-off customers, and of course nobody wants that. Twitter and Facebook
will light up with complaints about how your product is buggy, doesn't do what
was advertised, has trouble integrating with other software, keeps missing
release dates, and so forth. And yes, that can indeed be a headache.

But if you screw up the first one, you're going to have \textit{no} customers.
And believe me, that's a lot worse. Your well-built, snazzy-looking, bug-free
little product isn't going to get any airtime on social media because
\textit{nobody cares}. It simply isn't something people find worth using, and
so all the great engineering in the world isn't going to be of any use.

Incidentally, if there's lots of complaining on the Internet about how your
product is buggy, that's actually a really nice situation to have. It means
that people are using your code, and that they care enough to gripe. You've
(partially) solved a problem that they genuinely want solved, and that means
that ultimately, if you can manage to get \#2 under control, you're going to
have a market and a chance at a big success.

Here's another thought experiment: why, if \#1 is the most important thing to
get right, do we spend almost the entire Computer Science curriculum teaching
students how to do \#2 well? Think about it: just about every CPSC course
you've taken (and will ever take) involves some aspect of \#2.

I think there are several answers to this, but much of it comes down to the
fact that \#1 is just harder to teach. It's certainly not as predictable as
\#2 is. Not as much is known about it. For the various aspects of \#2, there
are quite a few reliable and even quantifiable techniques that the Computer
Science community has discovered and which have stood the test of time. If you
follow best practices, you're going to end up building your code right. But
knowing what program to write in the first place is a different realm
entirely, and it requires a lot of intuition about people and their
fickleness. 

Steve Jobs was a genius at \#1, and he had Steve Wozniak as his wingman doing
\#2. When top engineers came and went at Apple, the company could survive the
changes because the principles they were using were transcendent. When Jobs
wasn't there, though, you could sure see the difference.

\section{Capturing requirements}

This chapter is a brief look at \#1. It's a different phase of the
\textbf{software development lifecycle} than you're used to focusing on. A
simplified picture of this lifecycle is given in Figure~\ref{fig:swDevCycle}.
Each box represents an \textbf{artifact}, which as you may remember
(p.~\pageref{artifact}) means the tangible result of some software development
activity. The arrows between boxes are labeled with those activities, or
``processes.'' During the time that your development team is working on a
particular process (sometimes called ``being in a particular \textbf{phase}'')
they are focused on producing the artifact at the end of the arrowhead. That
artifact will capture the result of their thinking in a tangible form, where
it can then be the input to the next phase.

\begin{figure}
\centering
\includegraphics[width=1\textwidth]{swDevCycle.pdf}
\caption{A simplified depiction of the software development lifecycle.}
\label{fig:swDevCycle}
\end{figure}

Any application starts with an \textbf{idea}, of course, which is ``something
that could exist, but doesn't yet.'' For bite-size projects, one could set to
work coding up the idea directly, dispensing with most of this diagram. But
for larger projects this doesn't work very well. The first problem is that
there is often not enough detail specified about ``the idea'' yet to know how
to proceed. In other words, the design team doesn't yet fully know what the
\textbf{requirements}\footnote{``\textbf{Requirement}'' is just a loose term
for ``something the proposed software system is \textit{required} to do.''
Whatever form they may ultimately take, ``the requirements'' spell out what
the design team needs to know in order to build what's expected of them. The
requirements are a sort of contract between the management and engineering
teams.} are for the system they're being tasked to build. The activity of
\textbf{requirements formulation} is intended to remedy this situation. There
have been various methodologies proposed for coaxing a more detailed
description of what the proposed software is supposed to actually \textit{do},
one of which (Use Cases) is the subject of this chapter. Regardless of how
they are elucidated, though, the result is some form of \textbf{requirements
specification} (or ``req spec") as we first saw on p.\pageref{reqSpec}.

Churning out a \textbf{design document} from a req spec is the subject of
\textbf{design}, of course, which we covered in chapters \ref{design1} and
\ref{design2}. The term ``\textbf{implementation}'' is a fancy word for
``coding'' in a programming language like Java. The \textbf{testing} phase
typically involves both \textbf{unit testing} and \textbf{system testing},
which work at different levels of granularity to ensure that each individual
software component works according to its specification, and that the system
as a whole does. Finally, \textbf{deploying} the product to the user base is
the culmination of a release cycle, and is usually cause for much celebration
(and sometimes, alcohol.)

As I indicated, Figure~\ref{fig:swDevCycle} is simplified to the point of
being na\"{i}ve. For one thing, in a real life software process the various
phases loop back upon each other: you always learn things in one phase (say,
design) that make you go back and revise the work in an earlier phase (say,
requirements formulation). Also, it's rare that an entire, fully-functional
system gets built in just one execution of this step-by-step chain. Today's
software teams \textbf{iterate} through this process, or portions thereof,
multiple times as they converge on a fully-implemented product. Moreover,
larger projects have different groups of people working on different parts of
the lifecycle: a ``requirements team'' with input from marketing, a ``design
team'' led by an architect that focuses on strategic implementation concerns,
a ``programming team'' to actually write the code, ``test teams'' and ``QA
(quality assurance) teams'' to handle the last few phases, \textit{etc.}
Figure~\ref{fig:swDevCycle} is really a caricature of the necessary phases,
and one simple way they might fit together.

For now, though, the diagram suffices for our needs. My only real motive for
showing it to you is to help you mentally place this chapter's content in the
proper overall position, namely:

\begin{quote}
\textit{This chapter concerns the \textbf{requirements formulation} phase.}
\end{quote} 

Unlike everything else we've discussed, we're not writing code here, or even
figuring out a UML design. We're simply describing \textbf{what} our
object-oriented program needs to do, when it is ultimately built.

\subsection{``What'' vs. ``how''}

The dichotomy between ``what'' and ``how'' runs deep through human thought,
well beyond just software development. Think of a military hierarchy in
wartime. The general may decide that \textbf{what} needs to happen in a
particular campaign is to cut off enemy access to a water source, and focus
troops in the western flatter region where the enemy is vulnerable. The
Lieutenant Generals who work under him, however, need to take those ``whats''
and figure out ``\textbf{how}'' to make each of them happen. The Lt.~Gen.
assigned to the water source task may decide that a quiet amphibious landing
upstream from the source, simultaneously with a small group of shock troops at
water's edge as a distraction, is just the ticket. So that's \textbf{what}
this Lt.~Gen. decides to do. Each of his or her Colonels then need to unpack
those overarching plans to the next level and decide \textbf{how} to implement
them. And so forth. Every level of the hierarchy is a ``what'' for the
higher-up and a ``how'' for the underling. The same phenomenon is seen in the
Org Chart for a business, a government agency, a sports team, or even a
family.

Another pair of terms for this phenomenon are \textbf{strategy} and
\textbf{tactics}. Think of ``strategy'' as the ``what,'' and ``tactics'' as
the ``how.'' To continue the military analogy: sending a group of aircraft to
intercept an incoming bomber squadron might be considered a \textit{strategic}
decision. One of those aircraft banking left and then gaining altitude in a
flanking maneuver, however, is a \textit{tactical} move. And this dichotomy
persists throughout all levels of the plan: something that's a ``what'' to a
major becomes a ``how'' for his captain to solve, and ``what'' his captain
decides gets fleshed out in ``how'' his lieutenants decide to operationalize
it, \textit{etc.}

By the way, you'll sometimes hear people complain about
``\textbf{micromanaging}.'' Here's my definition of the term: when someone
``above'' you in the hierarchy is supposed to tell you \textbf{what} to do,
but instead starts telling you \textbf{how} to do it, they're micromanaging
you. It's a chafing feeling, and can quickly lead to resentment, because your
colleague is really overstepping their bounds. They should be outlining what
the requirements of the task are, and deferring to you on how specifically to
make that happen. On the other extreme are managers who fail to completely
specify the ``what,'' leaving you, as the ``how'' person, with insufficient
information about how you might proceed. A well-functioning organization is
one where everyone understands and honors these boundaries and is thus able to
carry out a complex task composed of many interlocking levels.


\section{Use Cases}

Use Cases are one methodology for capturing\footnote{``Capturing'' means
``identifying and then precisely describing.''} requirements. Rather than
describing the entire system in a block of text, as in our examples on
p.~\pageref{blockRequirements1} and
p.~\pageref{blockRequirements2}, we isolate and identify individual units of
functionality that a user of the system has available to her, and describe
each one. Each of these units of functionality is called a \textbf{use case}
(pronounced ``YOOS case,'' not ``YUZE case.'')

Here are some important terms:

\begin{description}
\item[Actor:] A role that a person plays when interacting with a system.
\item[Use Case (UC):] A function of the system that yields a result of value to an
Actor.
\item[UC description:] A detailed specification of exactly what happens
when the Actor executes the use case, including any important variants.
\item[UC diagram:] A mostly-useless picture showing which Actors are
intended to perform which UCs. Can be used to impress managers, and
makes a good cover page.
\end{description}

You can see that I'm slightly cynical about that last item. Unlike other UML
diagrams we've seen (class diagrams and sequence diagrams), a Use Case diagram
contains \textit{almost zero information}. That's because the UC descriptions
-- which are the important part of all this -- tell you everything the diagram
tells you, and much more.

For the record, though, Figure~\ref{fig:amazonUcDiag} presents a UC diagram
for an online bookseller (like Amazon). The large rectangle represents the
\textbf{system boundary}; in other words, the stuff inside the box is
functionality present inside the software system being described. Actors are
shown as stick figures, and UCs as ovals. A line from the former to the latter
means ``a person acting as this role can execute this use case.'' The
``«uses»'' arrows (with an open-triangle, like inheritance on a UML class
diagram) indicate a sort of ``subroutine'' relationship: in this case, the use
case ``Buy book'' will entail running the ``Add item to card,'' ``Checkout,''
and ``Update inventory'' use cases.

\begin{figure}
\centering
\includegraphics[width=1.1\textwidth]{amazonUcDiag.pdf}
\caption{A Use Case diagram for an online bookseller.}
\label{fig:amazonUcDiag}
\end{figure}

\subsubsection{About actors}

There's a couple things worth mentioning about Actors. For one, different
actors can sometimes execute the same UC. In our diagram, both the Anonymous
User and Registered User actors can ``Search for books,'' and both the
Registered User and the Critic can ``Login.'' This is clear from the diagram,
and easy enough to understand. The second thing worth mentioning, however, is
not explicit on the diagram, but is equally important: \textbf{an actor is a
\textit{role} that a person may play, not the person herself.}

What I mean is this. Someone might look at Figure~\ref{fig:amazonUcDiag} and
say, ``wait a minute -- mightn't a Critic who writes book reviews also
sometimes buy books on the site? Isn't it limiting to disallow Critics from
buying books?'' The answer is: the same human being may indeed sometimes
review books, and sometimes buy books. But \textit{she is acting in different
roles when she does so.} When this person writes a book review, she is in the
role of a ``Critic'' actor; when she makes a purchase, she is acting as a
``Registered User'' actor. So the Actors simply represent the various
different capacities in which human beings can act as they use the system.
There is certainly nothing preventing a person from embodying different roles
at different times.

\subsection{UC descriptions}

I mentioned that UC \textit{diagrams} are almost completely worthless. Their
main value-add in my experience is simply to look pretty and make a
nice-looking cover sheet for your Use Case model. But make no mistake, the
real work of the requirements phase -- and the important information -- is
found in the \textbf{Use Case description}s.




