
\chapter{Blueprints: UML class diagrams}

We spent last chapter discussing the \textbf{dynamic} view of a program: what
happens to memory, step by step, as it unfolds. In this chapter, we'll switch
to a \textbf{static} view: long-term, what are the program's classes, methods,
and relationships between them?\footnote{The words ``dynamic" and ``static"
are ubiquitous in computer science, and mean a zillion different unrelated
things. For example, we've already seen the Java ``\texttt{static}" keyword,
and how it indicates class-level rather than an object-level ownership. We've
also hinted at the stack having ``statically-allocated memory" and the heap
being ``dynamically-allocated." These terms are \textbf{\textit{unrelated}} to
our use of the words in this chapter. At present, by ``dynamic" we mean ``the
contents of memory changing as the program runs"; and by ``static" we mean
``the consistent, permanent characteristics of a program, quite apart from how
it might be behaving at any moment, which include its classes, methods, and
associations."}

If there's a type of UML diagram that deserves the name ``blueprint," it's the
\textbf{class diagram}. Class diagrams depict a high-level, stable perspective
of a software system. When you want to figure out how a large OO program
works, or when you're tasked with implementing a system that someone else has
designed, the first thing you look at are its class diagram(s).

UML class diagrams contain a number of elements, each of which has a very
specific meaning. We'll cover each in turn.

\section{Classes}

Unlike memory diagrams, which depict objects, class diagrams contain classes
(duh). We've already seen what a single class looks like in
section~\ref{sec:UMLclasses} (\textit{e.g.}, the left side of
Figure~\ref{fig:classObject}.) Most class diagrams contain many such classes.
Recall that each class has three compartments, containing the class's name,
its inst vars, and its methods, in that order.

By the way, one flexible (yet slightly annoying IMO) aspect of UML is that it
allows \textbf{varying levels of detail}. In other words, on a particular
diagram, you may or may not want to show all the instance variables and
methods, because it may or may not be relevant to the purpose of that
particular diagram. Similarly, you may or may not want to show all the aspects
of each inst var or method; perhaps it's too early in the design process to
completely specify all the parameters and return types, for example. To
illustrate, all three pictures in Figure~\ref{fig:graceful} are legit
ways of representing the \texttt{Car} class. We can include as much or as
little detail as we please.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{graceful.pdf}   % 670x320
\caption{Three equally valid ways to draw the \texttt{Car} class on a class
diagram, depending on how much detail it makes sense to include.}
\label{fig:graceful}
\end{figure}

The reason I find this annoying, by the way, is that it's ambiguous. If you
see no inst vars in the second box, does that mean (a) that class \textit{has}
no inst vars, or (b) the designer didn't think it was relevant to include them
on this particular diagram? No way to really know.

\section{Associations}

Perhaps the most important bits of information on a class diagram are the
\textbf{association}s between classes. An association means that two classes
collaborate together in some way to achieve some larger purpose. It is
indicated on a class diagram by a line connecting the two classes. Different
types of lines represent different kinds of relationships between the classes.
It's important not to mix them up, because if you do, you're dictating
something incorrect to the programming team about how the classes are intended
to work.

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{assocArrows.pdf}   % 350x200
\vspace{.2in}
\caption{Diagrammatic elements for different association types.}
\label{fig:assocArrows}
\end{figure}

\subsection{Dependency associations}

Figure~\ref{fig:assocArrows} shows some of the UML association arrows and
their meaning. (There are others we'll get to in future chapters.) The dashed
line with a crow's foot arrowhead is called a \textbf{dependency}, and is the
``weakest" of the association types. When I say weak, I mean that the
relationship between the two classes isn't as important, nor as permanent, as
with the other association types we'll discuss later.

A dependency between classes \texttt{A} and \texttt{B} can be thought of in a
couple of ways:

\begin{compactitem}
\item One or more methods of the \texttt{A} class will \textit{call methods
on} a \texttt{B} object.
\item The \texttt{A} class \textit{is dependent on the interface of} the
\texttt{B} class.
\end{compactitem}

The word \textbf{interface} -- like stack, heap, dynamic, static, and many
other computer science words -- has multiple meanings. We'll talk about the
Java \texttt{interface} keyword later in the book. For now, when I say
interface I mean \textit{those aspects of a class that a user of that type of
object can see.} This boils down to: the methods you can call on it, together
with their argument lists and return types. Specifically, the interface does
\textit{not} include the method implementations (the bodies of the methods),
nor the instance variables.

If you think about it, you'll realize why the above two bullet points are
actually equivalent. Suppose some class \texttt{A} method has this line of
code in it: ``\texttt{String s = B.scissorKick(15)}". Then clearly the code in
the \texttt{A.java} file is \textit{dependent} on the fact that class
\texttt{B} has a \texttt{.scissorKick()} method, and that it takes an integer,
and returns a \texttt{String}. If any of that ever changed in the
\texttt{B.java} file, then class \texttt{A} would be impacted.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{dependencyAssoc.pdf}   % 
\caption{Examples of dependency associations.}
\label{fig:dependencyExamples}
\end{figure}

The strange-looking words adjacent to the dependency arrows in
Figure~\ref{fig:assocArrows} go by the even stranger-sounding term
\textbf{stereotypes}. A stereotype in UML is an extra bit of information that
enhances part of a diagram (an association arrow, as here, or sometimes a
class, method, or other element) by making its meaning more precise.
Stereotypes are usually displayed enclosed by double-wakkas
(``$\ll$...$\gg$").

In the case of dependency associations, the stereotype ``$\ll$uses$\gg$" means
pretty much what a dependency always means: that the designer intends class
\texttt{A} to ``use" (\textit{i.e.}, get its hands on, and call method(s) on)
object(s) of class \texttt{B}. The ``$\ll$instantiates$\gg$" stereotype goes a
bit further, and implies that some method of \texttt{A} will
\textit{instantiate} \texttt{B} objects in addition to merely calling methods
on them.

The examples in Figure~\ref{fig:dependencyExamples} are from a Dungeons \&
Dragons type combat simulator. A \texttt{Battle} object represents a fight
between adventurers and monsters. While simulating this fight, a
\texttt{Battle} will make use of one or more \texttt{Die} (singular of ``dice")
objects to roll random numbers that determine the outcome. This is a
``$\ll$uses$\gg$" association, since \texttt{Battle}'s code now depends on
\texttt{Die}'s interface not changing.

Elsewhere in the program, wizards sometimes cast ranged spells, like fireballs
or lightning bolts, to damage distant enemies. In the simulator, a
\texttt{Wizard} object might therefore instantiate a \texttt{RangedSpell}
object to carry out this attack. Since somewhere in the \texttt{Wizard} class's
code there will be a ``\texttt{new RangedSpell()}" line, we say that
\texttt{Wizard} $\ll$instantiates$\gg$ \texttt{RangedSpell}.

\subsubsection{Dependencies in code}

Now what would we expect to see in the code that would reflect this kind of
association? In the ``$\ll$uses$\gg$" case, we expect to see one or more
methods of the \texttt{A} class making method calls on \texttt{B} objects.
Perhaps something like this:

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=single]
class Battle {
    ...
    void resolveAttack(Adventurer a, Monster m, Die d) {
        ...
        if (d.roll() < a.currentWeapon().attackStat()) {
            ...
        }
    }
    ...
}
\end{Verbatim}

The design diagram doesn't specify exactly what \texttt{A} method will be
called where, just that method calls are expected. This communicates something
important to the programmer.

For ``$\ll$instantiates$\gg$", we'd expect to see the word \texttt{new}
somewhere in \texttt{A}:

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=single]
class Wizard {
    ...
    void takeAction(ArrayList<Monster> enemies) {
        ...
        if (enemies.size() > 3) {
            RangedSpell fireball = new RangedSpell("Fireball", 60, 12);
            fireball.cast();
            ...
        }
    }
    ...
}
\end{Verbatim}

\subsection{``Has-a" associations}

The next strongest type of association has a bizarre name: it's called
``\textbf{has-a}." We denote it with a solid arrow between classes, with a
crow's foot on one side or both.

When class \texttt{A} has-a class \texttt{B}, that is nearly always a signal
to the programmer that \texttt{A} should have an \textit{instance variable} of
type \texttt{B}.\footnote{Or perhaps a \textbf{collection} of \texttt{B}
objects rather than a single \texttt{B} object, as we'll see later in the
chapter.} In other words, not only does an \texttt{A} object call
methods on a \texttt{B} (as in the dependency association), but an \texttt{A}
object actually holds on to one (or more) \texttt{B} objects for the
long-haul.

Now in some cases, the ``has-a" verbiage makes perfect sense. If our Domino's
Pizza delivery manager application had a \texttt{Pizza} class and a
\texttt{Topping} class, it would be no-brainer to say that every
\texttt{Pizza} has-a \texttt{Topping}. It conjures up in our minds a picture
of containment, or ownership. Perfect. However, we also use this type of
association in cases where containment doesn't make sense at all.

For example, in the same application it would be quite sensible to say that
``every \texttt{Pizza} has-a \texttt{DeliveryCar}." But obviously the delivery
car isn't ``inside" the pizza in the same physical way that the toppings are
inside it. So what does it mean then?

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{wrongRightHasA.pdf}   % 
\caption{The \textbf{wrong}, and \textbf{right}, way of visualizing a ``has-a"
association in Java.}
\label{fig:wrongRightHasA}
\end{figure}

The key is making sure you have the right mental model.
Figure~\ref{fig:wrongRightHasA} shows both the wrong, and the right, way to
envision a has-a relationship (at least, in Java). In memory, there is
\textit{no} ``containment" as in the left-hand (wrong) image. The
\texttt{Topping} object isn't enclosed inside the \texttt{Pizza}, or even
exclusively owned by it. It's simply pointed to by one of the \texttt{Pizza}
object's inst vars. The right-hand side of the figure is the correct one --
and I daresay it's not problematic at all to think of a \texttt{Pizza}
``having" a \texttt{DeliveryCar} in this way. All it really means is that a
\texttt{Pizza} object ``knows about" a \texttt{DeliveryCar}, which is the
particular car that's delivering it.

Another reason that the correct mental model of ``has-a" is important is that
it is possible, and even common, for the association to go \textit{both ways}.
We use the term \textbf{navigability} for the question ``which direction does
the arrow go -- from \texttt{A} to \texttt{B}, from \texttt{B} to \texttt{A},
or both?" When it goes both ways, we call it a \textbf{bidirectional}
association.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{bidirectional.pdf}   % 750x235
\caption{A bidirectional ``has-a," depicted on a class diagram (left) and a
memory diagram.}
\label{fig:bidirectional}
\end{figure}

An example is the left-hand side of Figure~\ref{fig:bidirectional}. Here, our
\texttt{Driver} class and our \texttt{DeliveryCar} class each know about the
other, and in fact each hold on to an instance variable of the other type. If
we viewed this \texttt{A}-having-an-instance-variable-of-type-\texttt{B} thing
as the \texttt{A} object \textit{enclosing} the \texttt{B}, we'd blow a fuse.
\texttt{A} would contain \texttt{B}, which would contain \texttt{A}, which
would contain \texttt{B}, which... That way madness lies. But notice that
nothing paradoxical happens at all in the corresponding memory diagram on the
right-hand side of the figure. Each object points to the other, so that a
\texttt{Driver} object knows which \texttt{DeliveryCar} he/she is driving, and
a \texttt{DeliveryCar} also knows which \texttt{Driver} is driving it. No
biggie.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{wrongHasA.pdf}   % 640x180
\caption{One wrong way to model an instance variable. The ``has-a" arrow
already indicates that every \texttt{Pizza} has-a \texttt{Topping}: the
extraneous \texttt{topping} entry in the \texttt{Pizza} class's second box is
redundant and incorrect.}
\label{fig:wrongHasA}
\end{figure}

Note, by the way, that the has-a arrow implies the existence of the inst var
\textit{all by itself}. The class diagram should \textit{not} contain a
duplicate copy of the inst var in its second compartment. That would be
redundant, and is considered an error (see Figure~\ref{fig:wrongHasA}).

\pagebreak
\subsubsection{``Has-a" associations in code}

Obviously instance variables are how ``has-a" associations are manifested in a
Java program. For \texttt{Pizza} and \texttt{Topping}, we'd see:

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=single]
class Pizza {
    ...
    Topping topping;
    ...
}
\end{Verbatim}

and for our bidirectional \texttt{Driver}/\texttt{DeliveryCar}, we'd see both
\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=single]
class Driver {
    ...
    DeliveryCar car;
    ...
}
\end{Verbatim}

and

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=single]
class DeliveryCar {
    ...
    Driver currentDriver;
    ...
}
\end{Verbatim}

These examples both assume that a \texttt{Pizza} has only \textit{one}
\texttt{Topping}, \textit{etc.} If this isn't so, we'd use some kind of
container class instead:

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=single]
class Pizza {
    ...
    ArrayList toppings;
    ...
}
\end{Verbatim}

More on that later.

\subsection{Aggregation associations}

Continuing on towards the ``stronger" end of the association continuum, an
\textbf{aggregation} implies exclusive ownership of the object(s) in question.
In other words, if \texttt{A} aggregates \texttt{B}, not only does it mean
that \texttt{A} has an instance variable of type \texttt{B}, but that
\textit{no other \texttt{A} object also has that \texttt{B}.}

This is frequently misinterpreted, so let me expand on that. The
``exclusivity" thing is a statement about \textit{objects}, not classes. If
\texttt{A} aggregates \texttt{B}, that does \textit{not} mean that no other
class can have an instance variable of type \texttt{B}. Rather, it means that
if a particular \texttt{B} object is pointed to by an \texttt{A} object, no
\textit{other} \texttt{A} object also points to that \texttt{B}.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{aggregationAssoc.pdf}   % 620x220
\caption{Examples of aggregation associations.}
\label{fig:aggregationAssoc}
\end{figure}

Examples appear in Figure~\ref{fig:aggregationAssoc}. Note that the diamond
appears on the ``aggregator" side; \textit{i.e.}, adjacent to the class that
will have the instance variable.

In the first example, for a Banner-like college enrollment management system,
each \texttt{Professor} will teach some number of \texttt{Section}s in a given
semester. If Professor Jones is assigned to teach section 03 of BIOL 121, then
no \textit{other} professor is also assigned to that section. That's what the
white diamond communicates.

In the second example, from a Facebook-like social networking site, users can
arrange their \texttt{Photo}s into \texttt{Album}s. As indicated on this
diagram, a given \texttt{Photo} is \textit{not} intended to simultaneously
belong to more than one \texttt{Album}. (If we wanted to relax that
constraint, and permit photos to belong to multiple albums at once, we would
get rid of our white diamond and use a plain-old ``has-a" arrow instead.)

\subsubsection{Aggregations in code}

Aggregation is intended to imply some sort of collection or ownership
relationship between the two classes. However, in terms of the Java code that
you initially write, \textit{there is no immediate difference between an
aggregation and a regular ``has-a."} In both cases, you'll make an inst var of
the appropriate type in the appropriate place. The code difference between
aggregation and has-a won't come out until later, when the class methods are
being implemented. That white diamond is more of a long-term signal to the
programmer about how two classes are generally intended to operate together,
rather than being a cue to write the first bit of code differently than you
otherwise would.

\subsection{Composition associations}

The last association type we'll cover, and the most tightly-binding between
classes, is called \textbf{composition}. It's a lot like aggregation (even the
diamond syntax is the same, except it's black) but with one difference. With
composition, not only does an \texttt{A} object have exclusive ownership over
its \texttt{B} object(s), but there's a \textbf{lifespan dependency} as well:
if the \texttt{A} ever disappears, its constituent \texttt{B}'s should also
cease to exist.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{compositionAssoc.pdf}   % 700x230
\caption{Examples of composition associations.}
\label{fig:compositionAssoc}
\end{figure}


Consider the examples in Figure~\ref{fig:compositionAssoc}. In this social
networking site, every \texttt{User} has a \texttt{Profile}. That
\texttt{User} is the \textit{only} one with that particular profile (hence
this is at least aggregation) and what's more, \textit{the \texttt{Profile}
has no meaningful existence without its \texttt{User}.} If the user ever
deletes their account, it wouldn't make sense to have a disembodied
\texttt{Profile} object lying around, so it should automatically disappear as
well. This lifespan connection is really the only difference between the white
diamond and the black.

On the right-hand side is an example from some kind of email reader
application (like Outlook, gmail, or Thunderbird). A user can compose an
\texttt{Email} with some text and a list of recipients, and then add
\texttt{Attachment}s to it to send images, documents, code, \textit{etc.} But
what if the user decides to abandon the message before sending it? The
\texttt{Email} object should go away, but its \texttt{Attachment}s should too.
Hence this is another example of composition.

\subsubsection{Compositions in code}

Just as with aggregations, there's no simple Java keyword that magically maps
to the idea of ``composition." Instead, the presence of the black diamond
suggests to the programmer the intended function of the classes involved, and
she will write the code with this in mind.


\subsection{Association annotations}

As if all this weren't enough, there are also a couple more syntactic things
to learn about UML associations. An \textbf{annotation} is another mark on
part of a diagram that gives more detail about how it is to be understood or
implemented. We've already seen two examples of this: the stereotypes we
included next to dependency lines are a type of annotation, as are the
arrowheads to indicate navigability. We'll learn two more in this section.

\subsubsection{Multiplicity}

The \textbf{multiplicity} of an association indicates \textit{how many}
objects are involved in each concrete relationship. It's important to realize
that even though multiplicity is shown on a class diagram, it's really a
statement about \textit{objects}.

Let's start with the left-most example in Figure~\ref{fig:multiplicity}. There
we have two classes from a DMV software system, connected with a ``has-a"
association between \texttt{Driver} and \texttt{License}, navigable both ways.
Note the numeral ``\textbf{1}" annotation both sides of the arrow. This
indicates that \textit{every \texttt{Driver} ``goes with" just one
\texttt{License} object}, and \textit{every \texttt{License} also goes with
just one \texttt{Driver}.} This is called a \textbf{one-to-one association},
sensibly enough.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{multiplicity.pdf}   % 790x270
\caption{Association annotations indicating multiplicity.}
\label{fig:multiplicity}
\end{figure}

In the center example, on the other hand, we have a ``$\star$" on the side of
the arrow that connects to \texttt{Weapon}. In UML, the symbol ``$\star$"
means \textbf{zero or more}. So here's how we interpret this
\textbf{one-to-many association}: every \texttt{Adventurer} has zero or more
weapons, while every \texttt{Weapon} is possessed by just one
\texttt{Adventurer}. Note that since the direction is only navigable in one
direction, this indicates that although an \texttt{Adventurer} is aware of
which \texttt{Weapon}s she owns, the \texttt{Weapon} objects are \textit{not}
aware of which \texttt{Adventurer} owns them. This knowledge (or lack thereof)
is perfectly okay, and does not invalidate the meaning of the \textbf{1} or
the $\star$ in the slightest.

Finally, on the right side, we have a \textbf{many-to-many association}
between \texttt{Transcript} and \texttt{Course}. This says that every
\texttt{Transcript} object is associated with potentially multiple
\texttt{Course} objects, while each \texttt{Course} object appears on more
than one \texttt{Transcript}. Navigability-wise, in this example
\texttt{Transcript}s maintain a record of which \texttt{Course}s they contain,
whereas \texttt{Course} objects don't know which \texttt{Transcript}s they
appear on (if any).

\subsubsection{Multiplicity in code}

What does all this look like in code? Well, first remember that inst vars are
only used in the direction(s) along which the association is navigable. For
Figure~\ref{fig:multiplicity}, this means that only \texttt{Driver},
\texttt{License}, \texttt{Adventurer}, and \texttt{Transcript} will have inst
vars related to these associations; \texttt{Weapon} and \texttt{Course} will
not. Furthermore, if the multiplicity is a \textbf{1}, the inst var will be 
of the type the arrow is pointing to; if it's a $\star$, it will be
\textit{some collection} of that type. Which sort of collection is used -- an
array, an \texttt{ArrayList}, a \texttt{Hashtable}, a \texttt{Set},
\textit{etc.} -- is normally up to the programmer, and is decided based on the 
run-time performance features of that collection type.

So here's some code we might reasonably expect to see from our three examples:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single]
    class Driver {                        class Adventurer {
        String name;                          String name;
        License license;                      int hitPoints;
        ...                                   ArrayList<Weapon> weapons;
    }                                         ...
                                          }
    class License {
        String number;                    class Transcript {
        Driver owner;                         Course[] courses;
        ...                                   ...
    }                                     }
\end{Verbatim}

Here the programmer of the \texttt{Adventurer} class has chosen to use an
\texttt{ArrayList} to hold each adventurer's weapons, while the
\texttt{Transcript} author decided on a simple array. In terms of being
faithful to the design, neither choice is right or wrong.

\subsubsection{Roles}

Our last type of association annotation has to do with \textbf{roles}.
Sometimes, a design will be specific not only about the \textit{existence} of
the association between two classes, and about which-knows-about-which, and
about how-many-are-involved, but also the intended \textit{meaning} of the
relationship. In other words, it may specify what role each of the object
types is expected to play with respect to the other. This may sound a bit
abstract, but some examples will make it clearer.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{roles.pdf}   % 670x400
\caption{Association annotations indicating roles.}
\label{fig:roles}
\end{figure}

The upper-left example in Figure~\ref{fig:roles} shows a piece of a Marvel
comic book database application. We have \texttt{Hero} and \texttt{Villain}
classes, and a one-to-one association between them...but what does the
association \textit{mean}? If \texttt{Hero X} ``goes with" \texttt{Villain Y},
does that mean that \texttt{X} has recently beaten up \texttt{Y}? That
\texttt{X} admires \texttt{Y}? That \texttt{X} secretly \textit{is}
\texttt{Y}, unbeknownst to the public?

The word ``archnemesis" next to the \texttt{Villain}-side of the arrow spells
it out. It's called a \textbf{role name}. It tells us that in this
relationship, the role that the \texttt{Villain} plays with respect to the
\texttt{Hero} is that the former is the archenemy of the latter.

Moving to the right side of the diagram, we have an interesting situation
involving only one class: \texttt{TwitterUser}. This class apparently has an
association to itself! This turns out not to be as weird as it might seem. In
fact, if you think about a social network like Twitter, the most meaningful
relationships \textit{are} between objects of the same class. And that's the
key to de-weirding it in your mind: remember that an association is a
statement about \textit{objects}, not classes. We're not saying
``\texttt{TwitterUser} has a relationship with itself" but rather ``each
\texttt{TwitterUser} is related to zero or more other \texttt{TwitterUser}s."

And what do those relations mean, you ask? The role name tells us: one of the
users ``follows" the other in the Twitter sense. In this diagram, we have role
names on both sides of the arrow, although that's probably not strictly
necessary. What is interesting here is the navigability of the association:
according to the design, a \texttt{TwitterUser} object is aware of what other
\texttt{TwitterUser}s follow him/her, but not which \texttt{TwitterUser}s
he/she follows. If the design team decided they needed to track that
separately, they'd need another arrowhead on the top side of the line.

Finally, the bottom example illustrates two \textit{different} associations
between the same two classes. This can happen as well. In this case, there are
two distinct roles that \texttt{Professor}s play with respect to
\texttt{Student}s: as their instructors (each student has several) and as
their advisor (each student has one). The role names are imperative here,
since otherwise the programming team would be lost as to why there are two
relationships and what each one is supposed to mean.

\subsubsection{Roles in code}

Often, the role name on the diagram is simply used as the instance variable
name in the code. For instance, I'd expect to see something like this:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single]
class Student {
    String major;    
    Professor advisor;
    ArrayList<Professor> instructors;
}
\end{Verbatim}

since those names were handed to us on a silver platter in the design diagram.


